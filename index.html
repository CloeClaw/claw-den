<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>THE CONTINENTAL ‚Äî Agent Operations</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a0a; font-family: monospace; }
canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; cursor: crosshair; }
#ui { position: fixed; top: 10px; right: 10px; z-index: 10; }
#controlPanel { background: rgba(20,12,8,0.95); border: 2px solid #C9A84C; padding: 12px; border-radius: 4px; color: #d4c4a0; font-size: 12px; min-width: 200px; backdrop-filter: blur(4px); }
#controlPanel h3 { color: #C9A84C; margin-bottom: 10px; font-size: 13px; text-align: center; letter-spacing: 2px; border-bottom: 1px solid rgba(201,168,76,0.3); padding-bottom: 6px; }
.ctrl-row { margin: 5px 0; display: flex; justify-content: space-between; align-items: center; }
.ctrl-row label { font-size: 11px; }
.ctrl-row select { background: #1a0f08; color: #d4c4a0; border: 1px solid #6b5530; font-size: 11px; font-family: monospace; padding: 2px 4px; border-radius: 2px; }
#statusPanel { position: fixed; top: 10px; left: 10px; z-index: 10; background: rgba(20,12,8,0.95); border: 2px solid #C9A84C; padding: 12px; border-radius: 4px; color: #d4c4a0; font-size: 11px; min-width: 220px; backdrop-filter: blur(4px); max-width: 280px; }
#statusPanel h3 { color: #C9A84C; margin-bottom: 8px; font-size: 12px; text-align: center; letter-spacing: 3px; border-bottom: 1px solid rgba(201,168,76,0.3); padding-bottom: 6px; }
.agent-status { margin: 8px 0; padding: 6px; border-left: 2px solid #333; transition: border-color 0.3s; }
.agent-status.active { border-left-color: #00ff41; }
.agent-status.thinking { border-left-color: #C9A84C; }
.agent-status.offline { border-left-color: #333; opacity: 0.5; }
.agent-status .name { font-weight: bold; color: #C9A84C; font-size: 12px; }
.agent-status .role { color: #8b7340; font-size: 10px; margin: 2px 0; }
.agent-status .task { color: #00ff41; font-size: 10px; }
.agent-status .task.planned { color: #555; font-style: italic; }
#statusCard { display: none; position: fixed; background: rgba(20,12,8,0.96); border: 2px solid #C9A84C; padding: 12px; border-radius: 4px; color: #d4c4a0; font-family: monospace; font-size: 12px; z-index: 20; min-width: 200px; pointer-events: none; }
#statusCard h4 { color: #C9A84C; margin-bottom: 6px; }
#statusCard .role { color: #8b7340; font-size: 11px; }
#statusCard .task { color: #00ff41; margin-top: 4px; }
#statusCard .stat { color: #998870; font-size: 10px; margin-top: 4px; }
#soundToggle { position: fixed; bottom: 30px; right: 10px; z-index: 10; background: rgba(20,12,8,0.9); border: 1px solid #6b5530; color: #d4c4a0; font-family: monospace; font-size: 11px; padding: 6px 10px; cursor: pointer; border-radius: 3px; transition: border-color 0.3s; }
#soundToggle:hover { border-color: #C9A84C; }
#ticker { position: fixed; bottom: 0; left: 0; right: 0; height: 24px; background: rgba(10,6,4,0.95); border-top: 1px solid #C9A84C; z-index: 10; overflow: hidden; font-family: monospace; font-size: 11px; line-height: 24px; color: #C9A84C; white-space: nowrap; }
#tickerText { display: inline-block; animation: scroll 45s linear infinite; }
@keyframes scroll { 0% { transform: translateX(100vw); } 100% { transform: translateX(-100%); } }
@media (max-width: 768px) {
  #statusPanel { display: none; }
  #controlPanel { min-width: 160px; font-size: 10px; padding: 8px; }
  #controlPanel h3 { font-size: 11px; }
  .ctrl-row label { font-size: 10px; }
  .ctrl-row select { font-size: 10px; }
  #soundToggle { bottom: 28px; font-size: 10px; padding: 4px 8px; }
}
@media (max-width: 480px) {
  #ui { top: 5px; right: 5px; }
  #controlPanel { min-width: 140px; padding: 6px; }
}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="statusPanel">
  <h3>‚óÜ OPERATIONS ‚óÜ</h3>
  <div class="agent-status active" id="sp-cloe">
    <div class="name">ü¶ä Cloe</div>
    <div class="role">Strategy & Apps</div>
    <div class="task">‚ö° Bang Brush content plan</div>
  </div>
  <div class="agent-status thinking" id="sp-glenn">
    <div class="name">üê∫ Glenn Gary</div>
    <div class="role">Trading & Analysis</div>
    <div class="task">üí≠ Polymarket category analysis</div>
  </div>
  <div class="agent-status active" id="sp-mallory">
    <div class="name">‚ú® Mallory</div>
    <div class="role">AI Influencer</div>
    <div class="task">üì∏ Content creation</div>
  </div>
  <div class="agent-status offline" id="sp-scout">
    <div class="name">üì° Scout</div>
    <div class="role">Intel Scanner</div>
    <div class="task planned">üîß Deployment planned</div>
  </div>
</div>

<div id="ui">
<div id="controlPanel">
<h3>‚óÜ CONTROL ‚óÜ</h3>
<div class="ctrl-row"><label>Cloe:</label><select id="ctrl-cloe"><option value="working">Working ‚ö°</option><option value="thinking">Thinking üí≠</option><option value="chatting">Chatting üí¨</option><option value="idle">Idle</option><option value="sleeping">Sleeping üí§</option><option value="alert">Alert ‚ùó</option></select></div>
<div class="ctrl-row"><label>Glenn:</label><select id="ctrl-glenn-gary"><option value="thinking">Thinking üí≠</option><option value="working">Working ‚ö°</option><option value="chatting">Chatting üí¨</option><option value="idle">Idle</option><option value="sleeping">Sleeping üí§</option><option value="alert">Alert ‚ùó</option></select></div>
<div class="ctrl-row"><label>Mallory:</label><select id="ctrl-mallory"><option value="working">Working ‚ö°</option><option value="thinking">Thinking üí≠</option><option value="chatting">Chatting üí¨</option><option value="idle">Idle</option><option value="sleeping">Sleeping üí§</option><option value="alert">Alert ‚ùó</option></select></div>
</div>
</div>

<div id="statusCard"><h4 id="sc-name"></h4><div class="role" id="sc-role"></div><div class="task" id="sc-task"></div><div class="stat" id="sc-stat"></div></div>
<button id="soundToggle" onclick="toggleSound()">üîá Sound</button>
<div id="ticker"><span id="tickerText">‚óÜ THE CONTINENTAL ‚Äî All agents operational ‚óÜ CLOE deployed 3 sites to GitHub Pages ‚óÜ GLENN completed Day 5 analysis ‚óÜ MALLORY onboarded ‚Äî content pipeline active ‚óÜ SCOUT deployment in planning ‚óÜ PORTFOLIO: $90.60 ‚óÜ SITES LIVE: 4 ‚óÜ BANG BRUSH site launched ‚óÜ REPURPOSE AI prototype ready ‚óÜ POLYMARKET research ongoing ‚óÜ</span></div>

<script>
// ============================================================
// THE CONTINENTAL ‚Äî Agent Activity Dashboard v3
// ============================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, SCALE;
const VW = 480, VH = 320;

function resize() {
  const ar = VW / VH;
  if (window.innerWidth / window.innerHeight > ar) {
    H = window.innerHeight; W = H * ar;
  } else {
    W = window.innerWidth; H = W / ar;
  }
  canvas.width = W; canvas.height = H;
  SCALE = W / VW;
  ctx.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

// ============================================================
// STATUS DATA
// ============================================================
const agentData = {
  agents: [
    { id: "cloe", name: "Cloe", role: "Strategy & Apps", status: "working", task: "Bang Brush content plan", uptime: "4h 23m", emoji: "ü¶ä" },
    { id: "glenn-gary", name: "Glenn Gary", role: "Trading & Analysis", status: "thinking", task: "Polymarket category analysis", uptime: "2h 17m", emoji: "üê∫" },
    { id: "mallory", name: "Mallory", role: "AI Influencer", status: "working", task: "Content creation", uptime: "0h 45m", emoji: "‚ú®" },
    { id: "scout", name: "Scout", role: "Intel Scanner", status: "sleeping", task: "Deployment planned", uptime: "‚Äî", emoji: "üì°" }
  ]
};

document.getElementById('ctrl-cloe').addEventListener('change', e => { agentData.agents[0].status = e.target.value; agents[0].onStatusChange(); updateStatusPanel(); });
document.getElementById('ctrl-glenn-gary').addEventListener('change', e => { agentData.agents[1].status = e.target.value; agents[1].onStatusChange(); updateStatusPanel(); });
document.getElementById('ctrl-mallory').addEventListener('change', e => { agentData.agents[2].status = e.target.value; agents[2].onStatusChange(); updateStatusPanel(); });

function updateStatusPanel() {
  const icons = { working: '‚ö°', thinking: 'üí≠', chatting: 'üí¨', idle: 'üò¥', sleeping: 'üí§', alert: '‚ùó' };
  const classes = { working: 'active', thinking: 'thinking', chatting: 'active', idle: 'offline', sleeping: 'offline', alert: 'active' };
  agentData.agents.forEach(a => {
    const el = document.getElementById('sp-' + a.id);
    if (!el) return;
    el.className = 'agent-status ' + (classes[a.status] || 'offline');
    el.querySelector('.task').textContent = (icons[a.status] || '') + ' ' + a.task;
  });
}

// ============================================================
// PIXEL FONT
// ============================================================
const FONT = {};
const fontDef = {
  'A':'111101111101','B':'110101110101110','C':'111100100100111','D':'110101101101110',
  'E':'111100110100111','F':'111100110100100','G':'111100101101111','H':'101101111101101',
  'I':'111010010010111','J':'011001001101110','K':'101101110101101','L':'100100100100111',
  'M':'101111111101101','N':'101111111111101','O':'111101101101111','P':'110101110100100',
  'Q':'111101101111011','R':'110101110101101','S':'111100111001111','T':'111010010010010',
  'U':'101101101101111','V':'101101101101010','W':'101101111111101','X':'101101010101101',
  'Y':'101101010010010','Z':'111001010100111',
  '0':'111101101101111','1':'010110010010111','2':'111001111100111','3':'111001111001111',
  '4':'101101111001001','5':'111100111001111','6':'111100111101111','7':'111001001001001',
  '8':'111101111101111','9':'111101111001111',
  ' ':'000000000000000',':':'000010000010000','-':'000000111000000','.':'000000000000010',
  '/':'001001010100100','!':'010010010000010','?':'111001010000010','&':'010101010101011',
  '\'':'010010000000000','$':'111110111011111','(':'010100100100010',')':'010001001001010',
  ',':'000000000010100','#':'000111000111000','+':'000010111010000','<':'001010100010001',
  '>':'100010001010100','=':'000111000111000','%':'101001010100101','@':'111101111100111',
  '*':'000101010101000','~':'000011101100000'
};
Object.keys(fontDef).forEach(ch => {
  const s = fontDef[ch]; const w = 3, h = 5, d = [];
  for (let i = 0; i < h; i++) { d[i] = []; for (let j = 0; j < w; j++) d[i][j] = s[i*w+j] === '1' ? 1 : 0; }
  FONT[ch] = d;
});

function drawText(text, x, y, color, scale) {
  scale = scale || 1;
  const s = text.toUpperCase();
  let cx = x;
  for (let i = 0; i < s.length; i++) {
    const g = FONT[s[i]];
    if (g) {
      ctx.fillStyle = color;
      for (let r = 0; r < 5; r++) for (let c = 0; c < 3; c++) {
        if (g[r][c]) ctx.fillRect((cx + c * scale) * SCALE, (y + r * scale) * SCALE, scale * SCALE, scale * SCALE);
      }
    }
    cx += 4 * scale;
  }
  return cx - x;
}

function textWidth(text, scale) { return text.length * 4 * (scale||1) - (scale||1); }

// ============================================================
// COLORS
// ============================================================
const COL = {
  bg1: '#0a0a0a', bg2: '#1a0f08', accent: '#C9A84C', gold: '#C9A84C', goldDim: '#8b7340',
  darkWood: '#2C1810', burgundy: '#4a1520',
  cloe1: '#d4a574', cloe2: '#c6883e', cloe3: '#a06828', cloeTail: '#e8bc7a',
  glenn1: '#4a6fa5', glenn2: '#2d3a4a', glenn3: '#1f2833', glennEye: '#00ff41',
  mallory1: '#8B6952', mallory2: '#6B4F3D', mallory3: '#5A3E2E', malloryHair: '#2A1A10', malloryCopperHL: '#B87333', malloryTop: '#1a1a2e', malloryAccent: '#C9A84C',
  white: '#d4c4a0', floor1: '#0e0806', floor2: '#140e0a',
  desk: '#2C1810', monitor: '#0a1a0a', monitorGlow: '#00ff41',
  couch1: '#4a1520', couch2: '#6a2535',
  coffee: '#3a2a1a', window1: '#0a0a1a', star: '#ffffff',
  skyline: '#0d1525', building1: '#141e30', building2: '#1a2840',
  wallTrim: '#3a2815',
  plant1: '#1a4a1a', plant2: '#2a6a2a', plant3: '#3a8a3a', pot: '#6a3a1a',
};

// ============================================================
// ROOM LAYOUT
// ============================================================
const ROOM = {
  floorY: 200,
  wallScreen: { x: 170, y: 35, w: 140, h: 70 },
  cloeDesk: { x: 50, y: 170, w: 50, h: 25 },
  glennDesk: { x: 310, y: 170, w: 55, h: 25 },
  malloryDesk: { x: 180, y: 175, w: 48, h: 22 },
  scoutStation: { x: 400, y: 110, w: 40, h: 30 },
  couch: { x: 200, y: 245, w: 70, h: 25 },
  coffee: { x: 440, y: 235, w: 20, h: 30 },
  window: { x: 8, y: 25, w: 80, h: 75 },
  clock: { x: 120, y: 35, w: 30, h: 30 },
  plant1: { x: 100, y: 178, w: 10, h: 20 },
  plant2: { x: 375, y: 180, w: 8, h: 18 },
  plant3: { x: 460, y: 175, w: 10, h: 22 },
  poi: {
    cloeStation: { x: 70, y: 210 },
    glennStation: { x: 330, y: 210 },
    malloryStation: { x: 200, y: 215 },
    couch: { x: 235, y: 258 },
    coffeeMachine: { x: 448, y: 260 },
    windowView: { x: 48, y: 210 },
    center: { x: 240, y: 240 },
  }
};

// ============================================================
// DRAW ROOM ELEMENTS
// ============================================================
function drawFloor() {
  for (let y = ROOM.floorY; y < VH; y += 16) {
    for (let x = 0; x < VW; x += 16) {
      const checker = ((x / 16 | 0) + (y / 16 | 0)) % 2;
      ctx.fillStyle = checker ? COL.floor1 : COL.floor2;
      ctx.fillRect(x * SCALE, y * SCALE, 16 * SCALE, 16 * SCALE);
    }
  }
  // Subtle marble veining
  ctx.fillStyle = 'rgba(201,168,76,0.02)';
  for (let y = ROOM.floorY; y < VH; y += 8) {
    ctx.fillRect(0, y * SCALE, VW * SCALE, SCALE);
  }
  // Floor reflection streaks
  ctx.fillStyle = 'rgba(201,168,76,0.015)';
  for (let x = 20; x < VW; x += 60) {
    ctx.fillRect(x * SCALE, ROOM.floorY * SCALE, 2 * SCALE, (VH - ROOM.floorY) * SCALE);
  }
}

function drawWalls() {
  const grad = ctx.createLinearGradient(0, 0, 0, ROOM.floorY * SCALE);
  grad.addColorStop(0, '#120a06');
  grad.addColorStop(1, '#1a0f08');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, VW * SCALE, ROOM.floorY * SCALE);
  // Wainscoting panels
  for (let x = 0; x < VW; x += 60) {
    ctx.fillStyle = 'rgba(201,168,76,0.04)';
    ctx.fillRect((x + 2) * SCALE, 10 * SCALE, 56 * SCALE, (ROOM.floorY - 14) * SCALE);
    ctx.fillStyle = 'rgba(201,168,76,0.06)';
    ctx.fillRect(x * SCALE, 8 * SCALE, SCALE, (ROOM.floorY - 10) * SCALE);
  }
  // Wall bottom trim
  ctx.fillStyle = COL.darkWood;
  ctx.fillRect(0, (ROOM.floorY - 6) * SCALE, VW * SCALE, 6 * SCALE);
  ctx.fillStyle = '#C9A84C';
  ctx.fillRect(0, (ROOM.floorY - 6) * SCALE, VW * SCALE, SCALE);
  ctx.fillRect(0, (ROOM.floorY - 1) * SCALE, VW * SCALE, SCALE);
  // Top crown molding
  ctx.fillStyle = COL.darkWood;
  ctx.fillRect(0, 0, VW * SCALE, 4 * SCALE);
  ctx.fillStyle = 'rgba(201,168,76,0.3)';
  ctx.fillRect(0, 3 * SCALE, VW * SCALE, SCALE);
}

function drawWallClock(t) {
  const c = ROOM.clock;
  const cx = c.x + c.w / 2, cy = c.y + c.h / 2;
  ctx.fillStyle = '#C9A84C';
  ctx.beginPath(); ctx.arc(cx * SCALE, cy * SCALE, (c.w/2 + 2) * SCALE, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#0a0604';
  ctx.beginPath(); ctx.arc(cx * SCALE, cy * SCALE, (c.w/2) * SCALE, 0, Math.PI * 2); ctx.fill();
  for (let i = 0; i < 12; i++) {
    const a = (i / 12) * Math.PI * 2 - Math.PI / 2;
    const r = c.w / 2 - 3;
    ctx.fillStyle = '#C9A84C';
    ctx.fillRect((cx + Math.cos(a) * r) * SCALE, (cy + Math.sin(a) * r) * SCALE, SCALE, SCALE);
  }
  const now = new Date();
  const hr = now.getHours() % 12 + now.getMinutes() / 60;
  const mn = now.getMinutes() + now.getSeconds() / 60;
  const sc = now.getSeconds();
  ctx.strokeStyle = '#C9A84C'; ctx.lineWidth = 2 * SCALE;
  let ha = (hr / 12) * Math.PI * 2 - Math.PI / 2;
  ctx.beginPath(); ctx.moveTo(cx * SCALE, cy * SCALE); ctx.lineTo((cx + Math.cos(ha) * 7) * SCALE, (cy + Math.sin(ha) * 7) * SCALE); ctx.stroke();
  let ma = (mn / 60) * Math.PI * 2 - Math.PI / 2;
  ctx.lineWidth = 1.5 * SCALE;
  ctx.beginPath(); ctx.moveTo(cx * SCALE, cy * SCALE); ctx.lineTo((cx + Math.cos(ma) * 10) * SCALE, (cy + Math.sin(ma) * 10) * SCALE); ctx.stroke();
  let sa2 = (sc / 60) * Math.PI * 2 - Math.PI / 2;
  ctx.strokeStyle = '#aa3333'; ctx.lineWidth = SCALE;
  ctx.beginPath(); ctx.moveTo(cx * SCALE, cy * SCALE); ctx.lineTo((cx + Math.cos(sa2) * 11) * SCALE, (cy + Math.sin(sa2) * 11) * SCALE); ctx.stroke();
  ctx.fillStyle = '#C9A84C'; ctx.beginPath(); ctx.arc(cx * SCALE, cy * SCALE, 1.5 * SCALE, 0, Math.PI * 2); ctx.fill();
  // Pendulum
  const pendAngle = Math.sin(t * 2) * 0.3;
  const px = cx + Math.sin(pendAngle) * 8;
  const py = cy + c.h/2 + 12 + Math.cos(pendAngle) * 2;
  ctx.strokeStyle = 'rgba(201,168,76,0.4)'; ctx.lineWidth = SCALE;
  ctx.beginPath(); ctx.moveTo(cx * SCALE, (cy + c.h/2) * SCALE); ctx.lineTo(px * SCALE, py * SCALE); ctx.stroke();
  ctx.fillStyle = '#C9A84C'; ctx.beginPath(); ctx.arc(px * SCALE, py * SCALE, 2.5 * SCALE, 0, Math.PI * 2); ctx.fill();
}

function drawWindow(t) {
  const w = ROOM.window;
  ctx.fillStyle = COL.darkWood;
  ctx.fillRect((w.x - 4) * SCALE, (w.y - 4) * SCALE, (w.w + 8) * SCALE, (w.h + 8) * SCALE);
  ctx.fillStyle = 'rgba(201,168,76,0.4)';
  ctx.fillRect((w.x - 4) * SCALE, (w.y - 4) * SCALE, (w.w + 8) * SCALE, SCALE);
  ctx.fillRect((w.x - 4) * SCALE, (w.y + w.h + 3) * SCALE, (w.w + 8) * SCALE, SCALE);
  // Curtains
  ctx.fillStyle = '#3a1520';
  ctx.fillRect((w.x - 8) * SCALE, (w.y - 6) * SCALE, 7 * SCALE, (w.h + 14) * SCALE);
  ctx.fillRect((w.x + w.w + 1) * SCALE, (w.y - 6) * SCALE, 7 * SCALE, (w.h + 14) * SCALE);
  // Curtain folds
  for (let cy = w.y; cy < w.y + w.h; cy += 6) {
    ctx.fillStyle = 'rgba(201,168,76,0.06)';
    ctx.fillRect((w.x - 6) * SCALE, cy * SCALE, 3 * SCALE, 3 * SCALE);
    ctx.fillRect((w.x + w.w + 3) * SCALE, cy * SCALE, 3 * SCALE, 3 * SCALE);
  }
  // Curtain rod
  ctx.fillStyle = '#C9A84C';
  ctx.fillRect((w.x - 10) * SCALE, (w.y - 7) * SCALE, (w.w + 20) * SCALE, 2 * SCALE);
  // Sky
  const grad = ctx.createLinearGradient(w.x * SCALE, w.y * SCALE, w.x * SCALE, (w.y + w.h) * SCALE);
  grad.addColorStop(0, '#030310'); grad.addColorStop(1, '#0d1525');
  ctx.fillStyle = grad;
  ctx.fillRect(w.x * SCALE, w.y * SCALE, w.w * SCALE, w.h * SCALE);
  // Moon
  ctx.fillStyle = '#ffffcc';
  ctx.beginPath(); ctx.arc((w.x + 60) * SCALE, (w.y + 15) * SCALE, 6 * SCALE, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#030310';
  ctx.beginPath(); ctx.arc((w.x + 63) * SCALE, (w.y + 13) * SCALE, 5 * SCALE, 0, Math.PI * 2); ctx.fill();
  // Moon glow
  ctx.fillStyle = 'rgba(255,255,200,0.03)';
  ctx.beginPath(); ctx.arc((w.x + 60) * SCALE, (w.y + 15) * SCALE, 15 * SCALE, 0, Math.PI * 2); ctx.fill();
  // Stars ‚Äî twinkling
  const stars = [[10,8],[25,5],[40,12],[55,20],[15,25],[70,8],[35,30],[65,35],[20,40],[50,45],[75,15],[30,15],[8,45],[62,50]];
  stars.forEach(([sx, sy], i) => {
    const bright = Math.sin(t * 2 + i * 1.7) * 0.3 + 0.7;
    ctx.fillStyle = `rgba(255,255,220,${bright})`;
    ctx.fillRect((w.x + sx) * SCALE, (w.y + sy) * SCALE, SCALE, SCALE);
    if (bright > 0.85) {
      ctx.fillStyle = `rgba(255,255,220,${(bright-0.85)*2})`;
      ctx.fillRect((w.x + sx - 1) * SCALE, (w.y + sy) * SCALE, SCALE, SCALE);
      ctx.fillRect((w.x + sx + 1) * SCALE, (w.y + sy) * SCALE, SCALE, SCALE);
      ctx.fillRect((w.x + sx) * SCALE, (w.y + sy - 1) * SCALE, SCALE, SCALE);
      ctx.fillRect((w.x + sx) * SCALE, (w.y + sy + 1) * SCALE, SCALE, SCALE);
    }
  });
  // Skyline
  const buildings = [[5,45,10,25],[17,38,8,32],[27,50,12,20],[41,42,7,28],[50,48,14,22],[66,40,10,30]];
  buildings.forEach(([bx, by, bw, bh]) => {
    ctx.fillStyle = COL.building1;
    ctx.fillRect((w.x + bx) * SCALE, (w.y + by) * SCALE, bw * SCALE, bh * SCALE);
    for (let wy = by + 3; wy < by + bh - 2; wy += 5) {
      for (let wx = bx + 2; wx < bx + bw - 2; wx += 4) {
        const lit = Math.sin(wx * 7 + wy * 3 + t * 0.3) > 0.2;
        ctx.fillStyle = lit ? 'rgba(201,168,76,0.8)' : '#0a0a1a';
        ctx.fillRect((w.x + wx) * SCALE, (w.y + wy) * SCALE, 2 * SCALE, 2 * SCALE);
      }
    }
  });
  // Window dividers
  ctx.fillStyle = COL.darkWood;
  ctx.fillRect((w.x + w.w / 2 - 1) * SCALE, w.y * SCALE, 2 * SCALE, w.h * SCALE);
  ctx.fillRect(w.x * SCALE, (w.y + w.h / 2 - 1) * SCALE, w.w * SCALE, 2 * SCALE);
}

function drawWallScreen(t) {
  const s = ROOM.wallScreen;
  // Ornate frame
  ctx.fillStyle = COL.darkWood;
  ctx.fillRect((s.x - 6) * SCALE, (s.y - 6) * SCALE, (s.w + 12) * SCALE, (s.h + 12) * SCALE);
  // Gold border with corner ornaments
  ctx.fillStyle = '#C9A84C';
  ctx.fillRect((s.x - 5) * SCALE, (s.y - 5) * SCALE, (s.w + 10) * SCALE, SCALE);
  ctx.fillRect((s.x - 5) * SCALE, (s.y + s.h + 4) * SCALE, (s.w + 10) * SCALE, SCALE);
  ctx.fillRect((s.x - 5) * SCALE, (s.y - 5) * SCALE, SCALE, (s.h + 10) * SCALE);
  ctx.fillRect((s.x + s.w + 4) * SCALE, (s.y - 5) * SCALE, SCALE, (s.h + 10) * SCALE);
  // Corner ornaments
  const corners = [[s.x-5, s.y-5],[s.x+s.w+2, s.y-5],[s.x-5, s.y+s.h+2],[s.x+s.w+2, s.y+s.h+2]];
  corners.forEach(([cx,cy]) => {
    ctx.fillStyle = '#C9A84C';
    ctx.fillRect(cx*SCALE, cy*SCALE, 3*SCALE, 3*SCALE);
    ctx.fillStyle = '#E0C060';
    ctx.fillRect((cx+1)*SCALE, (cy+1)*SCALE, SCALE, SCALE);
  });
  // Screen bg
  ctx.fillStyle = '#050202';
  ctx.fillRect(s.x * SCALE, s.y * SCALE, s.w * SCALE, s.h * SCALE);
  // Scanlines
  for (let y = s.y; y < s.y + s.h; y += 2) {
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(s.x * SCALE, y * SCALE, s.w * SCALE, SCALE);
  }
  // THE CONTINENTAL ‚Äî elegant gold with shadow
  drawText('THE CONTINENTAL', s.x + (s.w - textWidth('THE CONTINENTAL', 2))/2 + 1, s.y + 7, 'rgba(0,0,0,0.5)', 2);
  drawText('THE CONTINENTAL', s.x + (s.w - textWidth('THE CONTINENTAL', 2))/2, s.y + 6, '#C9A84C', 2);
  // Decorative dividers
  ctx.fillStyle = 'rgba(201,168,76,0.5)';
  ctx.fillRect((s.x + 8) * SCALE, (s.y + 19) * SCALE, (s.w - 16) * SCALE, SCALE);
  // Diamond ornaments on divider
  const divMid = s.x + s.w/2;
  ctx.fillStyle = '#C9A84C';
  ctx.fillRect((divMid - 1) * SCALE, (s.y + 18) * SCALE, 3 * SCALE, 3 * SCALE);
  // Clock display
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
  const tw = textWidth(timeStr, 1);
  drawText(timeStr, s.x + (s.w - tw) / 2, s.y + 25, '#C9A84C', 1);
  const dateStr = now.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
  const dw = textWidth(dateStr, 1);
  drawText(dateStr, s.x + (s.w - dw) / 2, s.y + 33, '#8b7340', 1);
  // Agent status dots
  const statusColors = { working: '#00ff41', thinking: '#C9A84C', chatting: '#00aaff', idle: '#666', sleeping: '#333', alert: '#ff4444' };
  agentData.agents.forEach((a, i) => {
    const dotX = s.x + 10 + i * 34;
    const dotY = s.y + 44;
    ctx.fillStyle = statusColors[a.status] || '#666';
    const pulse = Math.sin(t * 3 + i) * 0.3 + 0.7;
    ctx.globalAlpha = a.status === 'alert' ? pulse : (a.id === 'scout' ? 0.3 : 1);
    ctx.fillRect(dotX * SCALE, dotY * SCALE, 4 * SCALE, 4 * SCALE);
    ctx.globalAlpha = 1;
    const nm = a.name.substring(0, 6);
    drawText(nm, dotX - 2, dotY + 7, a.id === 'scout' ? '#555' : '#d4c4a0', 1);
  });
  // Subtitle
  drawText('EST. 2026', s.x + (s.w - textWidth('EST. 2026', 1))/2, s.y + 58, 'rgba(201,168,76,0.3)', 1);
  // Screen glow
  const grad = ctx.createRadialGradient(
    (s.x + s.w/2) * SCALE, (s.y + s.h/2) * SCALE, 5 * SCALE,
    (s.x + s.w/2) * SCALE, (s.y + s.h/2) * SCALE, 80 * SCALE
  );
  grad.addColorStop(0, 'rgba(201,168,76,0.03)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect((s.x - 40) * SCALE, (s.y - 20) * SCALE, (s.w + 80) * SCALE, (s.h + 60) * SCALE);
}

function drawDesk(d, monitorCount, glowColor) {
  ctx.fillStyle = COL.desk;
  ctx.fillRect(d.x * SCALE, d.y * SCALE, d.w * SCALE, d.h * SCALE);
  ctx.fillStyle = '#1a0c06';
  ctx.fillRect(d.x * SCALE, (d.y + d.h - 2) * SCALE, d.w * SCALE, 2 * SCALE);
  ctx.fillStyle = 'rgba(201,168,76,0.15)';
  ctx.fillRect(d.x * SCALE, d.y * SCALE, d.w * SCALE, SCALE);
  for (let i = 0; i < monitorCount; i++) {
    const mx = d.x + 5 + i * 18;
    const my = d.y - 18;
    ctx.fillStyle = '#111';
    ctx.fillRect(mx * SCALE, my * SCALE, 15 * SCALE, 14 * SCALE);
    ctx.fillStyle = '#0a1a0a';
    ctx.fillRect((mx + 1) * SCALE, (my + 1) * SCALE, 13 * SCALE, 11 * SCALE);
    ctx.fillStyle = glowColor || '#001a00';
    ctx.fillRect((mx + 2) * SCALE, (my + 2) * SCALE, 11 * SCALE, 9 * SCALE);
    // Monitor stand
    ctx.fillStyle = '#111';
    ctx.fillRect((mx + 6) * SCALE, (my + 14) * SCALE, 3 * SCALE, 3 * SCALE);
    // Screen content flicker
    for (let sy = 0; sy < 4; sy++) {
      ctx.fillStyle = `rgba(0,255,65,${0.05 + Math.sin(time * 4 + i + sy * 2) * 0.03})`;
      ctx.fillRect((mx + 3) * SCALE, (my + 3 + sy * 2) * SCALE, 9 * SCALE, SCALE);
    }
  }
  ctx.fillStyle = '#1a0c06';
  ctx.fillRect(d.x * SCALE, (d.y + d.h) * SCALE, 3 * SCALE, 15 * SCALE);
  ctx.fillRect((d.x + d.w - 3) * SCALE, (d.y + d.h) * SCALE, 3 * SCALE, 15 * SCALE);
}

function drawTradingTerminal(t) {
  const d = ROOM.glennDesk;
  const mx = d.x + 5, my = d.y - 18;
  for (let m = 0; m < 3; m++) {
    const ox = mx + m * 18;
    for (let row = 0; row < 3; row++) {
      const val = Math.sin(t * 2.5 + row * 3.7 + m * 5.3);
      const color = val > 0 ? '#00ff41' : '#ff4444';
      const num = (val * 100).toFixed(0);
      drawText((val > 0 ? '+' : '') + num, ox + 2, my + 3 + row * 3, color, 1);
    }
  }
}

function drawMalloryMonitor(t) {
  const d = ROOM.malloryDesk;
  const mx = d.x + 5, my = d.y - 18;
  // Show social media style content
  for (let m = 0; m < 2; m++) {
    const ox = mx + m * 18;
    // Purple/pink glow for influencer vibe
    ctx.fillStyle = `rgba(200,100,255,${0.05 + Math.sin(t * 3 + m) * 0.03})`;
    ctx.fillRect((ox + 2) * SCALE, (my + 2) * SCALE, 11 * SCALE, 9 * SCALE);
    // Little "image" rectangles
    ctx.fillStyle = `rgba(200,100,255,${0.15 + Math.sin(t * 2 + m * 3) * 0.05})`;
    ctx.fillRect((ox + 3) * SCALE, (my + 3) * SCALE, 5 * SCALE, 4 * SCALE);
    // Text lines
    ctx.fillStyle = 'rgba(200,180,255,0.2)';
    ctx.fillRect((ox + 3) * SCALE, (my + 8) * SCALE, 8 * SCALE, SCALE);
  }
}

function drawCouch() {
  const c = ROOM.couch;
  ctx.fillStyle = COL.couch1;
  ctx.fillRect(c.x * SCALE, (c.y - 8) * SCALE, c.w * SCALE, 10 * SCALE);
  ctx.fillStyle = COL.couch2;
  ctx.fillRect(c.x * SCALE, (c.y + 2) * SCALE, c.w * SCALE, c.h * SCALE);
  // Gold tufts
  ctx.fillStyle = 'rgba(201,168,76,0.3)';
  for (let bx = c.x + 8; bx < c.x + c.w - 5; bx += 12) {
    ctx.fillRect(bx * SCALE, (c.y - 3) * SCALE, SCALE, SCALE);
  }
  ctx.fillStyle = COL.couch1;
  ctx.fillRect((c.x + c.w / 3) * SCALE, (c.y + 2) * SCALE, SCALE, (c.h - 2) * SCALE);
  ctx.fillRect((c.x + 2 * c.w / 3) * SCALE, (c.y + 2) * SCALE, SCALE, (c.h - 2) * SCALE);
  // Arms
  ctx.fillStyle = COL.couch1;
  ctx.fillRect((c.x - 4) * SCALE, (c.y - 5) * SCALE, 5 * SCALE, (c.h + 10) * SCALE);
  ctx.fillRect((c.x + c.w - 1) * SCALE, (c.y - 5) * SCALE, 5 * SCALE, (c.h + 10) * SCALE);
  // Throw pillow
  ctx.fillStyle = '#C9A84C';
  ctx.fillRect((c.x + 5) * SCALE, (c.y - 4) * SCALE, 10 * SCALE, 7 * SCALE);
  ctx.fillStyle = '#8b7340';
  ctx.fillRect((c.x + 6) * SCALE, (c.y - 3) * SCALE, 8 * SCALE, 5 * SCALE);
  // Legs
  ctx.fillStyle = '#1a0a0a';
  ctx.fillRect(c.x * SCALE, (c.y + c.h) * SCALE, 3 * SCALE, 4 * SCALE);
  ctx.fillRect((c.x + c.w - 3) * SCALE, (c.y + c.h) * SCALE, 3 * SCALE, 4 * SCALE);
}

function drawCoffeeMachine(t) {
  const c = ROOM.coffee;
  ctx.fillStyle = '#3a2815';
  ctx.fillRect(c.x * SCALE, c.y * SCALE, c.w * SCALE, c.h * SCALE);
  ctx.fillStyle = '#2a1a0a';
  ctx.fillRect((c.x + 2) * SCALE, (c.y + 2) * SCALE, (c.w - 4) * SCALE, 8 * SCALE);
  ctx.fillStyle = 'rgba(201,168,76,0.4)';
  ctx.fillRect((c.x + 1) * SCALE, (c.y + 11) * SCALE, (c.w - 2) * SCALE, SCALE);
  // LED
  ctx.fillStyle = Math.sin(t * 4) > 0 ? '#ff3333' : '#aa1111';
  ctx.fillRect((c.x + c.w - 4) * SCALE, (c.y + 3) * SCALE, 2 * SCALE, 2 * SCALE);
  ctx.fillStyle = '#1a0c06';
  ctx.fillRect((c.x + 3) * SCALE, (c.y + 14) * SCALE, (c.w - 6) * SCALE, 10 * SCALE);
  // Coffee mug
  ctx.fillStyle = '#d4c4a0';
  ctx.fillRect((c.x + 5) * SCALE, (c.y + 18) * SCALE, 6 * SCALE, 5 * SCALE);
  ctx.fillStyle = '#3a2010';
  ctx.fillRect((c.x + 6) * SCALE, (c.y + 18) * SCALE, 4 * SCALE, 2 * SCALE);
  // Handle
  ctx.fillStyle = '#d4c4a0';
  ctx.fillRect((c.x + 11) * SCALE, (c.y + 19) * SCALE, 2 * SCALE, 3 * SCALE);
  // Multi-wisp steam
  for (let s = 0; s < 4; s++) {
    const phase = t * 3 + s * 1.8;
    const sx = c.x + 5 + s * 1.5 + Math.sin(phase) * 1.5;
    const sy = c.y + 14 - Math.abs(Math.sin(phase * 0.7)) * 5;
    const alpha = 0.15 + Math.sin(phase) * 0.08;
    ctx.fillStyle = `rgba(200,190,170,${alpha})`;
    ctx.fillRect(sx * SCALE, sy * SCALE, SCALE, 2 * SCALE);
    ctx.fillStyle = `rgba(200,190,170,${alpha * 0.5})`;
    ctx.fillRect((sx + Math.sin(phase + 1) * 0.8) * SCALE, (sy - 2) * SCALE, SCALE, SCALE);
    ctx.fillStyle = `rgba(200,190,170,${alpha * 0.25})`;
    ctx.fillRect((sx + Math.sin(phase + 2) * 1.2) * SCALE, (sy - 4) * SCALE, SCALE, SCALE);
  }
  // Table
  ctx.fillStyle = COL.darkWood;
  ctx.fillRect((c.x - 5) * SCALE, (c.y + c.h) * SCALE, (c.w + 10) * SCALE, 3 * SCALE);
  ctx.fillStyle = 'rgba(201,168,76,0.15)';
  ctx.fillRect((c.x - 5) * SCALE, (c.y + c.h) * SCALE, (c.w + 10) * SCALE, SCALE);
  ctx.fillStyle = '#1a0c06';
  ctx.fillRect((c.x - 3) * SCALE, (c.y + c.h + 3) * SCALE, 3 * SCALE, 12 * SCALE);
  ctx.fillRect((c.x + c.w + 2) * SCALE, (c.y + c.h + 3) * SCALE, 3 * SCALE, 12 * SCALE);
}

function drawPlant(px, py, size, t) {
  // Pot
  ctx.fillStyle = COL.pot;
  ctx.fillRect((px - 1) * SCALE, (py + size - 5) * SCALE, (size + 2) * SCALE, 6 * SCALE);
  ctx.fillStyle = '#5a2a10';
  ctx.fillRect(px * SCALE, (py + size - 4) * SCALE, size * SCALE, 4 * SCALE);
  // Soil
  ctx.fillStyle = '#2a1a0a';
  ctx.fillRect(px * SCALE, (py + size - 5) * SCALE, size * SCALE, 2 * SCALE);
  // Leaves
  const cx = px + size / 2;
  for (let i = 0; i < 5; i++) {
    const angle = (i / 5) * Math.PI * 2 + t * 0.2;
    const sway = Math.sin(t * 1.5 + i * 1.3) * 1.5;
    const lx = cx + Math.cos(angle) * (size * 0.6) + sway;
    const ly = py + size - 8 + Math.sin(angle) * (size * 0.3);
    ctx.fillStyle = i % 2 === 0 ? COL.plant2 : COL.plant3;
    ctx.fillRect(lx * SCALE, ly * SCALE, 3 * SCALE, 2 * SCALE);
    ctx.fillStyle = COL.plant1;
    ctx.fillRect((lx + 1) * SCALE, (ly - 1) * SCALE, 2 * SCALE, SCALE);
  }
  // Stem
  ctx.fillStyle = COL.plant1;
  ctx.fillRect((cx - 0.5) * SCALE, (py + size - 10) * SCALE, SCALE, 6 * SCALE);
}

function drawScoutStation(t) {
  const s = ROOM.scoutStation;
  ctx.globalAlpha = 0.3;
  // Radar dish / telescope setup
  const cx = s.x + s.w / 2;
  const cy = s.y + 5;
  // Tripod
  ctx.fillStyle = '#4a4a4a';
  ctx.fillRect((cx - 1) * SCALE, (cy + 10) * SCALE, 2 * SCALE, 20 * SCALE);
  ctx.fillRect((cx - 8) * SCALE, (cy + 28) * SCALE, 6 * SCALE, 2 * SCALE);
  ctx.fillRect((cx + 2) * SCALE, (cy + 28) * SCALE, 6 * SCALE, 2 * SCALE);
  // Dish
  ctx.fillStyle = '#6a6a7a';
  ctx.beginPath();
  ctx.arc(cx * SCALE, cy * SCALE, 10 * SCALE, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#5a5a6a';
  ctx.beginPath();
  ctx.arc(cx * SCALE, cy * SCALE, 7 * SCALE, 0, Math.PI * 2);
  ctx.fill();
  // Radar sweep
  const sweepAngle = t * 2;
  ctx.fillStyle = 'rgba(0,255,100,0.3)';
  ctx.beginPath();
  ctx.moveTo(cx * SCALE, cy * SCALE);
  ctx.arc(cx * SCALE, cy * SCALE, 9 * SCALE, sweepAngle, sweepAngle + 0.5);
  ctx.fill();
  // Center dot
  ctx.fillStyle = '#00ff41';
  ctx.fillRect((cx - 1) * SCALE, (cy - 1) * SCALE, 2 * SCALE, 2 * SCALE);
  ctx.globalAlpha = 1;
  // Label
  ctx.globalAlpha = 0.4;
  drawText('SCOUT', cx - 8, cy + 33, '#6b5530', 1);
  drawText('COMING SOON', cx - 18, cy + 40, '#555', 1);
  ctx.globalAlpha = 1;
  // Blinking standby light
  if (Math.sin(t * 2) > 0.7) {
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#00ff41';
    ctx.fillRect((cx + 8) * SCALE, (cy + 12) * SCALE, 2 * SCALE, 2 * SCALE);
    ctx.globalAlpha = 1;
  }
}

function drawBookshelf() {
  const bx = 420, by = 35, bw = 48, bh = 85;
  ctx.fillStyle = COL.darkWood;
  ctx.fillRect(bx * SCALE, by * SCALE, bw * SCALE, bh * SCALE);
  // Gold trim
  ctx.fillStyle = 'rgba(201,168,76,0.25)';
  ctx.fillRect(bx * SCALE, by * SCALE, bw * SCALE, SCALE);
  ctx.fillRect(bx * SCALE, (by + bh - 1) * SCALE, bw * SCALE, SCALE);
  ctx.fillRect(bx * SCALE, by * SCALE, SCALE, bh * SCALE);
  ctx.fillRect((bx + bw - 1) * SCALE, by * SCALE, SCALE, bh * SCALE);
  const bookColors = ['#4a1520', '#1a3a2a', '#C9A84C', '#2a2040', '#5a2010', '#1a2a4a', '#3a1a3a', '#1a3a3a'];
  for (let sy = 0; sy < 4; sy++) {
    const shelfY = by + 3 + sy * 21;
    ctx.fillStyle = '#3a2515';
    ctx.fillRect((bx + 2) * SCALE, shelfY * SCALE, (bw - 4) * SCALE, 2 * SCALE);
    let bookX = bx + 3;
    for (let b = 0; b < 6; b++) {
      const bookW = 3 + ((sy * 6 + b) * 7 % 3);
      const bookH = 13 + ((sy * 6 + b) * 11 % 5);
      ctx.fillStyle = bookColors[(sy * 6 + b) % bookColors.length];
      ctx.fillRect(bookX * SCALE, (shelfY - bookH + 2) * SCALE, bookW * SCALE, bookH * SCALE);
      // Spine highlight
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.fillRect(bookX * SCALE, (shelfY - bookH + 2) * SCALE, SCALE, bookH * SCALE);
      bookX += bookW + 1;
      if (bookX > bx + bw - 5) break;
    }
  }
}

// ============================================================
// SPRITE DRAWING ‚Äî Characters
// ============================================================
function drawPixelBlock(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * SCALE, y * SCALE, w * SCALE, h * SCALE);
}

function drawCloe(x, y, frame, action, dir) {
  const f = frame | 0;
  const d = dir || 1;
  ctx.save();
  if (d < 0) { ctx.translate((x * 2 + 16) * SCALE, 0); ctx.scale(-1, 1); x = 0; }
  const bx = d < 0 ? 0 : x;
  const by = y;

  // Idle breathing
  const breathe = action === 'idle' ? Math.sin(f * 0.05) * 0.5 : 0;

  if (action === 'sleeping') {
    drawPixelBlock(bx + 2, by + 12, 12, 6, COL.cloe1);
    drawPixelBlock(bx + 4, by + 10, 10, 4, COL.cloe2);
    drawPixelBlock(bx + 12, by + 8, 3, 2, COL.cloe2);
    drawPixelBlock(bx + 3, by + 18, 4, 4, COL.cloe3);
    drawPixelBlock(bx + 10, by + 18, 4, 4, COL.cloe3);
    ctx.restore(); return;
  }

  // Ears with twitch
  const earTwitch = Math.sin(f * 0.08) > 0.95 ? -1 : 0;
  drawPixelBlock(bx + 2, by + earTwitch, 3, 4, COL.cloe2);
  drawPixelBlock(bx + 3, by + 1 + earTwitch, 1, 2, '#ffccaa');
  drawPixelBlock(bx + 9, by, 3, 4, COL.cloe2);
  drawPixelBlock(bx + 10, by + 1, 1, 2, '#ffccaa');
  // Head
  drawPixelBlock(bx + 2, by + 3, 10, 8, COL.cloe1);
  drawPixelBlock(bx + 3, by + 4, 8, 6, COL.cloe2);
  // Eyes
  const blinkCloe = (Math.sin(f * 0.033) > 0.97);
  if (blinkCloe) {
    drawPixelBlock(bx + 4, by + 6, 2, 1, '#1a1a1a');
    drawPixelBlock(bx + 8, by + 6, 2, 1, '#1a1a1a');
  } else {
    drawPixelBlock(bx + 4, by + 5, 2, 2, '#1a1a1a');
    drawPixelBlock(bx + 8, by + 5, 2, 2, '#1a1a1a');
    drawPixelBlock(bx + 4, by + 5, 1, 1, '#ffffff');
    drawPixelBlock(bx + 8, by + 5, 1, 1, '#ffffff');
  }
  // Nose/muzzle
  drawPixelBlock(bx + 6, by + 8, 2, 1, '#1a1a1a');
  drawPixelBlock(bx + 5, by + 7, 4, 2, '#e8c89a');
  // Body
  drawPixelBlock(bx + 3, by + 11 + breathe, 8, 8, COL.cloe1);
  drawPixelBlock(bx + 4, by + 12 + breathe, 6, 5, COL.cloe2);

  if (action === 'walking') {
    const legPhase = Math.sin(f * 0.4);
    drawPixelBlock(bx + 3, by + 19, 3, 4 + Math.max(0, legPhase * 2), COL.cloe3);
    drawPixelBlock(bx + 8, by + 19, 3, 4 + Math.max(0, -legPhase * 2), COL.cloe3);
    const tailOff = Math.sin(f * 0.5) * 2;
    drawPixelBlock(bx + 11, by + 13 + tailOff, 4, 2, COL.cloeTail);
    drawPixelBlock(bx + 13, by + 12 + tailOff, 2, 2, COL.cloeTail);
  } else if (action === 'typing') {
    drawPixelBlock(bx + 2, by + 13, 2, 3, COL.cloe3);
    drawPixelBlock(bx + 10, by + 13, 2, 3, COL.cloe3);
    const armBob = f % 4 < 2 ? 0 : 1;
    drawPixelBlock(bx + 1, by + 15 + armBob, 2, 2, COL.cloe1);
    drawPixelBlock(bx + 11, by + 16 - armBob, 2, 2, COL.cloe1);
    drawPixelBlock(bx + 4, by + 19, 3, 4, COL.cloe3);
    drawPixelBlock(bx + 7, by + 19, 3, 4, COL.cloe3);
    drawPixelBlock(bx + 11, by + 14, 4, 2, COL.cloeTail);
  } else if (action === 'thinking') {
    drawPixelBlock(bx + 10, by + 8, 3, 5, COL.cloe1);
    drawPixelBlock(bx + 4, by + 19, 3, 4, COL.cloe3);
    drawPixelBlock(bx + 7, by + 19, 3, 4, COL.cloe3);
    // Tail gentle sway
    const tailSway = Math.sin(f * 0.1) * 1;
    drawPixelBlock(bx + 11 + tailSway, by + 14, 4, 2, COL.cloeTail);
  } else {
    drawPixelBlock(bx + 4, by + 19, 3, 4, COL.cloe3);
    drawPixelBlock(bx + 7, by + 19, 3, 4, COL.cloe3);
    // Idle tail wag
    const tailWag = Math.sin(f * 0.15) * 1.5;
    drawPixelBlock(bx + 11 + tailWag, by + 14, 3, 2, COL.cloeTail);
    drawPixelBlock(bx + 13 + tailWag, by + 13, 2, 2, COL.cloeTail);
  }
  ctx.restore();
}

function drawGlenn(x, y, frame, action, dir) {
  const f = frame | 0;
  const d = dir || 1;
  ctx.save();
  if (d < 0) { ctx.translate((x * 2 + 16) * SCALE, 0); ctx.scale(-1, 1); x = 0; }
  const bx = d < 0 ? 0 : x;
  const by = y;
  const breathe = action === 'idle' ? Math.sin(f * 0.04) * 0.5 : 0;

  if (action === 'sleeping') {
    drawPixelBlock(bx + 2, by + 12, 12, 6, COL.glenn2);
    drawPixelBlock(bx + 4, by + 10, 10, 4, COL.glenn1);
    drawPixelBlock(bx + 12, by + 8, 3, 3, COL.glenn2);
    drawPixelBlock(bx + 3, by + 18, 4, 4, COL.glenn3);
    drawPixelBlock(bx + 10, by + 18, 4, 4, COL.glenn3);
    ctx.restore(); return;
  }

  // Ears
  drawPixelBlock(bx + 1, by - 1, 3, 5, COL.glenn2);
  drawPixelBlock(bx + 2, by, 1, 3, '#5a5a6a');
  drawPixelBlock(bx + 10, by - 1, 3, 5, COL.glenn2);
  drawPixelBlock(bx + 11, by, 1, 3, '#5a5a6a');
  // Head
  drawPixelBlock(bx + 2, by + 3, 10, 8, COL.glenn1);
  drawPixelBlock(bx + 3, by + 4, 8, 6, COL.glenn2);
  // Eyes ‚Äî glowing green
  const eyePulse = 0.8 + Math.sin(f * 0.05) * 0.2;
  ctx.globalAlpha = eyePulse;
  drawPixelBlock(bx + 4, by + 5, 2, 2, COL.glennEye);
  drawPixelBlock(bx + 8, by + 5, 2, 2, COL.glennEye);
  ctx.globalAlpha = 1;
  ctx.fillStyle = `rgba(0,255,65,0.15)`;
  ctx.fillRect((bx + 3) * SCALE, (by + 4) * SCALE, 4 * SCALE, 4 * SCALE);
  ctx.fillRect((bx + 7) * SCALE, (by + 4) * SCALE, 4 * SCALE, 4 * SCALE);
  drawPixelBlock(bx + 5, by + 7, 4, 3, '#3a4a5a');
  drawPixelBlock(bx + 6, by + 8, 2, 1, '#1a1a1a');
  // Body
  drawPixelBlock(bx + 2, by + 11 + breathe, 10, 8, COL.glenn2);
  drawPixelBlock(bx + 3, by + 12 + breathe, 8, 5, COL.glenn1);
  // Tie
  drawPixelBlock(bx + 6, by + 12 + breathe, 2, 4, '#C9A84C');

  if (action === 'walking') {
    const legPhase = Math.sin(f * 0.4);
    drawPixelBlock(bx + 3, by + 19, 3, 4 + Math.max(0, legPhase * 2), COL.glenn3);
    drawPixelBlock(bx + 8, by + 19, 3, 4 + Math.max(0, -legPhase * 2), COL.glenn3);
    drawPixelBlock(bx + 12, by + 13, 3, 2, COL.glenn2);
  } else if (action === 'typing' || action === 'analyzing') {
    drawPixelBlock(bx + 1, by + 13, 2, 3, COL.glenn3);
    drawPixelBlock(bx + 11, by + 13, 2, 3, COL.glenn3);
    const armBob = f % 4 < 2 ? 0 : 1;
    drawPixelBlock(bx, by + 15 + armBob, 2, 2, COL.glenn1);
    drawPixelBlock(bx + 12, by + 16 - armBob, 2, 2, COL.glenn1);
    drawPixelBlock(bx + 3, by + 19, 3, 4, COL.glenn3);
    drawPixelBlock(bx + 8, by + 19, 3, 4, COL.glenn3);
    drawPixelBlock(bx + 12, by + 14, 3, 2, COL.glenn2);
  } else if (action === 'thinking') {
    drawPixelBlock(bx + 11, by + 8, 3, 5, COL.glenn1);
    drawPixelBlock(bx + 3, by + 19, 3, 4, COL.glenn3);
    drawPixelBlock(bx + 8, by + 19, 3, 4, COL.glenn3);
    drawPixelBlock(bx + 12, by + 14, 3, 2, COL.glenn2);
  } else {
    drawPixelBlock(bx + 3, by + 19, 3, 4, COL.glenn3);
    drawPixelBlock(bx + 8, by + 19, 3, 4, COL.glenn3);
    // Idle tail wag
    const tailWag = Math.sin(f * 0.12) * 1;
    drawPixelBlock(bx + 12 + tailWag, by + 14, 3, 2, COL.glenn2);
  }
  ctx.restore();
}

function drawMallory(x, y, frame, action, dir) {
  const f = frame | 0;
  const d = dir || 1;
  ctx.save();
  if (d < 0) { ctx.translate((x * 2 + 16) * SCALE, 0); ctx.scale(-1, 1); x = 0; }
  const bx = d < 0 ? 0 : x;
  const by = y;
  const breathe = action === 'idle' ? Math.sin(f * 0.045) * 0.4 : 0;

  if (action === 'sleeping') {
    drawPixelBlock(bx + 2, by + 10, 12, 6, COL.mallory1);
    drawPixelBlock(bx + 3, by + 8, 10, 4, COL.malloryHair);
    drawPixelBlock(bx + 3, by + 16, 4, 4, COL.mallory3);
    drawPixelBlock(bx + 9, by + 16, 4, 4, COL.mallory3);
    ctx.restore(); return;
  }

  // Hair ‚Äî long, flowing, dark with copper highlights
  drawPixelBlock(bx + 1, by - 1, 12, 4, COL.malloryHair);
  drawPixelBlock(bx + 0, by + 2, 14, 3, COL.malloryHair);
  // Copper highlights
  drawPixelBlock(bx + 3, by, 2, 1, COL.malloryCopperHL);
  drawPixelBlock(bx + 8, by + 1, 2, 1, COL.malloryCopperHL);
  drawPixelBlock(bx + 1, by + 3, 1, 2, COL.malloryCopperHL);
  drawPixelBlock(bx + 12, by + 2, 1, 3, COL.malloryCopperHL);
  // Hair flowing down sides
  drawPixelBlock(bx, by + 5, 2, 8, COL.malloryHair);
  drawPixelBlock(bx + 12, by + 5, 2, 8, COL.malloryHair);
  drawPixelBlock(bx + 1, by + 6, 1, 6, COL.malloryCopperHL);
  drawPixelBlock(bx + 12, by + 7, 1, 5, COL.malloryCopperHL);

  // Face
  drawPixelBlock(bx + 2, by + 4, 10, 7, COL.mallory1);
  drawPixelBlock(bx + 3, by + 5, 8, 5, COL.mallory2);
  // Eyes
  const blink = Math.sin(f * 0.035) > 0.97;
  if (blink) {
    drawPixelBlock(bx + 4, by + 6, 2, 1, '#1a1a1a');
    drawPixelBlock(bx + 8, by + 6, 2, 1, '#1a1a1a');
  } else {
    drawPixelBlock(bx + 4, by + 5, 2, 2, '#2a1a10');
    drawPixelBlock(bx + 8, by + 5, 2, 2, '#2a1a10');
    drawPixelBlock(bx + 4, by + 5, 1, 1, '#ffffff');
    drawPixelBlock(bx + 8, by + 5, 1, 1, '#ffffff');
    // Eyelashes
    drawPixelBlock(bx + 3, by + 5, 1, 1, '#1a1a1a');
    drawPixelBlock(bx + 10, by + 5, 1, 1, '#1a1a1a');
  }
  // Lips
  drawPixelBlock(bx + 5, by + 8, 4, 1, '#c47a6a');
  // Nose
  drawPixelBlock(bx + 6, by + 7, 2, 1, COL.mallory2);

  // Body ‚Äî stylish dark top with gold accent
  drawPixelBlock(bx + 2, by + 11 + breathe, 10, 8, COL.malloryTop);
  drawPixelBlock(bx + 3, by + 12 + breathe, 8, 5, '#252540');
  // Necklace
  drawPixelBlock(bx + 4, by + 11 + breathe, 6, 1, COL.malloryAccent);
  drawPixelBlock(bx + 6, by + 12 + breathe, 2, 1, COL.malloryAccent);

  if (action === 'walking') {
    const legPhase = Math.sin(f * 0.4);
    drawPixelBlock(bx + 3, by + 19, 3, 4 + Math.max(0, legPhase * 2), COL.mallory3);
    drawPixelBlock(bx + 8, by + 19, 3, 4 + Math.max(0, -legPhase * 2), COL.mallory3);
    // Hair sway
    const sway = Math.sin(f * 0.3) * 1;
    drawPixelBlock(bx - 1 + sway, by + 10, 2, 4, COL.malloryHair);
    drawPixelBlock(bx + 13 - sway, by + 10, 2, 4, COL.malloryHair);
  } else if (action === 'typing') {
    drawPixelBlock(bx + 1, by + 13, 2, 3, COL.mallory3);
    drawPixelBlock(bx + 11, by + 13, 2, 3, COL.mallory3);
    const armBob = f % 4 < 2 ? 0 : 1;
    drawPixelBlock(bx, by + 15 + armBob, 2, 2, COL.mallory1);
    drawPixelBlock(bx + 12, by + 16 - armBob, 2, 2, COL.mallory1);
    drawPixelBlock(bx + 4, by + 19, 3, 4, COL.mallory3);
    drawPixelBlock(bx + 7, by + 19, 3, 4, COL.mallory3);
  } else if (action === 'thinking') {
    // Hand to chin pose
    drawPixelBlock(bx + 10, by + 7, 3, 5, COL.mallory1);
    drawPixelBlock(bx + 4, by + 19, 3, 4, COL.mallory3);
    drawPixelBlock(bx + 7, by + 19, 3, 4, COL.mallory3);
  } else {
    drawPixelBlock(bx + 4, by + 19, 3, 4, COL.mallory3);
    drawPixelBlock(bx + 7, by + 19, 3, 4, COL.mallory3);
  }
  ctx.restore();
}

// ============================================================
// STATUS ICONS
// ============================================================
function drawStatusIcon(x, y, status, t) {
  const bob = Math.sin(t * 3) * 2;
  if (status === 'working') {
    drawPixelBlock(x + 4, y - 10 + bob, 3, 2, '#ffdd00');
    drawPixelBlock(x + 3, y - 8 + bob, 3, 2, '#ffdd00');
    drawPixelBlock(x + 2, y - 6 + bob, 5, 1, '#ffdd00');
    drawPixelBlock(x + 4, y - 5 + bob, 3, 2, '#ffdd00');
    drawPixelBlock(x + 5, y - 3 + bob, 2, 2, '#ffdd00');
  } else if (status === 'thinking') {
    drawPixelBlock(x + 8, y - 6 + bob, 8, 6, 'rgba(255,255,255,0.8)');
    drawPixelBlock(x + 9, y - 7 + bob, 6, 8, 'rgba(255,255,255,0.8)');
    drawPixelBlock(x + 6, y - 2 + bob, 2, 2, 'rgba(255,255,255,0.6)');
    drawPixelBlock(x + 4, y + bob, 1, 1, 'rgba(255,255,255,0.4)');
    drawText('...', x + 9, y - 5 + bob, '#666', 1);
  } else if (status === 'chatting') {
    drawPixelBlock(x + 6, y - 10 + bob, 14, 8, '#ffffff');
    drawPixelBlock(x + 7, y - 11 + bob, 12, 10, '#ffffff');
    drawPixelBlock(x + 5, y - 2 + bob, 3, 3, '#ffffff');
    drawText('HI!', x + 8, y - 9 + bob, '#333', 1);
  } else if (status === 'sleeping') {
    const z1 = Math.sin(t * 2) * 1;
    const z2 = Math.sin(t * 2 + 1) * 1;
    const z3 = Math.sin(t * 2 + 2) * 1;
    drawText('Z', x + 10, y - 4 + z1, 'rgba(201,168,76,0.9)', 1);
    drawText('Z', x + 14, y - 10 + z2, 'rgba(201,168,76,0.6)', 1);
    drawText('Z', x + 18, y - 16 + z3, 'rgba(201,168,76,0.3)', 1);
  } else if (status === 'alert') {
    const bounce = Math.abs(Math.sin(t * 5)) * 4;
    drawPixelBlock(x + 5, y - 12 - bounce, 4, 6, '#ff3333');
    drawPixelBlock(x + 6, y - 12 - bounce, 2, 4, '#ff5555');
    drawPixelBlock(x + 6, y - 4 - bounce, 2, 2, '#ff3333');
  }
}

// ============================================================
// PARTICLE SYSTEM
// ============================================================
const particles = [];
for (let i = 0; i < 45; i++) {
  particles.push({
    x: Math.random() * VW, y: Math.random() * VH,
    vx: (Math.random() - 0.5) * 0.15, vy: -Math.random() * 0.08 - 0.02,
    life: Math.random(), size: Math.random() * 1.5 + 0.5,
    shimmer: Math.random() * Math.PI * 2
  });
}

function updateParticles(dt) {
  particles.forEach(p => {
    p.x += p.vx + Math.sin(p.shimmer + time * 0.5) * 0.03;
    p.y += p.vy;
    p.life -= 0.0008;
    p.shimmer += 0.02;
    if (p.life <= 0 || p.y < 0 || p.x < 0 || p.x > VW) {
      p.x = Math.random() * VW; p.y = ROOM.floorY + Math.random() * (VH - ROOM.floorY);
      p.life = 1; p.vy = -Math.random() * 0.08 - 0.02;
    }
  });
}

function drawParticles() {
  particles.forEach(p => {
    const shimmerBright = Math.sin(p.shimmer) * 0.08 + 0.12;
    ctx.fillStyle = `rgba(201,168,76,${p.life * shimmerBright})`;
    ctx.fillRect(p.x * SCALE, p.y * SCALE, p.size * SCALE, p.size * SCALE);
  });
}

// ============================================================
// AGENT AI / MOVEMENT
// ============================================================
class Agent {
  constructor(id, drawFn, stationPoi) {
    this.id = id;
    this.drawFn = drawFn;
    this.stationPoi = stationPoi;
    const poi = ROOM.poi[stationPoi];
    this.x = poi.x; this.y = poi.y;
    this.targetX = poi.x; this.targetY = poi.y;
    this.dir = 1;
    this.frame = 0;
    this.action = 'idle';
    this.moveTimer = 0;
    this.actionTimer = Math.random() * 200 + 100;
    this.speed = 0.5;
    this.atTarget = true;
  }
  getData() { return agentData.agents.find(a => a.id === this.id); }
  onStatusChange() { this.actionTimer = 0; }
  pickDestination() {
    const d = this.getData();
    if (!d) return;
    const status = d.status;
    const poi = ROOM.poi;
    if (status === 'working' || status === 'typing' || status === 'chatting' || status === 'alert') {
      this.goTo(Math.random() < 0.15 ? poi.coffeeMachine : poi[this.stationPoi]);
    } else if (status === 'thinking') {
      const choices = [poi[this.stationPoi], poi.windowView, poi.center, poi[this.stationPoi]];
      this.goTo(choices[Math.random() * choices.length | 0]);
    } else if (status === 'idle') {
      const all = [poi.couch, poi.coffeeMachine, poi.windowView, poi.center, poi[this.stationPoi]];
      this.goTo(all[Math.random() * all.length | 0]);
    } else if (status === 'sleeping') {
      this.goTo(poi.couch);
    }
    this.actionTimer = 150 + Math.random() * 300;
  }
  goTo(poi) {
    this.targetX = poi.x + (Math.random() - 0.5) * 10;
    this.targetY = poi.y + (Math.random() - 0.5) * 5;
    this.targetY = Math.max(ROOM.floorY + 5, Math.min(VH - 30, this.targetY));
    this.targetX = Math.max(20, Math.min(VW - 20, this.targetX));
    this.atTarget = false;
  }
  update(dt) {
    const d = this.getData();
    if (!d) return;
    this.frame += 0.1;
    this.actionTimer -= 1;
    if (this.actionTimer <= 0) this.pickDestination();
    const dx = this.targetX - this.x;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 2) {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
      this.dir = dx > 0 ? 1 : -1;
      this.action = 'walking';
      this.atTarget = false;
    } else {
      this.atTarget = true;
      const status = d.status;
      const atStation = Math.abs(this.x - ROOM.poi[this.stationPoi].x) < 20;
      if (status === 'working' || status === 'alert') this.action = atStation ? 'typing' : 'idle';
      else if (status === 'thinking') this.action = 'thinking';
      else if (status === 'chatting') this.action = atStation ? 'typing' : 'idle';
      else if (status === 'sleeping') this.action = 'sleeping';
      else this.action = 'idle';
    }
  }
  draw(t) {
    this.drawFn(this.x, this.y - 24, this.frame, this.action, this.dir);
    const d = this.getData();
    if (!d) return;
    const name = d.name.toUpperCase();
    const nw = textWidth(name, 1);
    // Name shadow
    drawText(name, this.x + 8 - nw / 2, this.y - 29, 'rgba(0,0,0,0.5)', 1);
    drawText(name, this.x + 7 - nw / 2, this.y - 30, COL.accent, 1);
    drawStatusIcon(this.x, this.y - 24, d.status, t);
  }
  containsPoint(px, py) {
    return px >= this.x - 5 && px <= this.x + 20 && py >= this.y - 30 && py <= this.y + 5;
  }
}

const agents = [
  new Agent('cloe', drawCloe, 'cloeStation'),
  new Agent('glenn-gary', drawGlenn, 'glennStation'),
  new Agent('mallory', drawMallory, 'malloryStation'),
];

// ============================================================
// CLICK / STATUS CARD
// ============================================================
const statusCard = document.getElementById('statusCard');
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / SCALE;
  const my = (e.clientY - rect.top) / SCALE;
  let found = false;
  agents.forEach(agent => {
    if (agent.containsPoint(mx, my)) {
      const d = agent.getData();
      if (d) {
        document.getElementById('sc-name').textContent = d.emoji + ' ' + d.name;
        document.getElementById('sc-role').textContent = d.role;
        document.getElementById('sc-task').textContent = 'üìã ' + d.task;
        document.getElementById('sc-stat').textContent = 'Status: ' + d.status + ' | Uptime: ' + d.uptime;
        statusCard.style.display = 'block';
        statusCard.style.left = Math.min(e.clientX + 10, window.innerWidth - 220) + 'px';
        statusCard.style.top = Math.max(e.clientY - 60, 10) + 'px';
        found = true;
        setTimeout(() => { statusCard.style.display = 'none'; }, 3000);
      }
    }
  });
  if (!found) statusCard.style.display = 'none';
});

// ============================================================
// SOUND ‚Äî Jazz lounge chiptune
// ============================================================
let audioCtx = null, soundOn = false;
function toggleSound() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  soundOn = !soundOn;
  document.getElementById('soundToggle').textContent = soundOn ? 'üîä Sound' : 'üîá Sound';
  if (soundOn) startAmbient(); else stopAmbient();
}

let ambientNodes = [];
let chiptuneInterval = null;

function startAmbient() {
  if (!audioCtx) return;
  const master = audioCtx.createGain();
  master.gain.value = 0.08;
  master.connect(audioCtx.destination);
  ambientNodes.push(master);

  const delay = audioCtx.createDelay();
  delay.delayTime.value = 0.2;
  const feedback = audioCtx.createGain();
  feedback.gain.value = 0.2;
  delay.connect(feedback);
  feedback.connect(delay);
  const wetGain = audioCtx.createGain();
  wetGain.gain.value = 0.12;
  delay.connect(wetGain);
  wetGain.connect(master);
  ambientNodes.push(delay, feedback, wetGain);

  // Warm pad
  const padNotes = [130.81, 164.81, 196.00, 246.94];
  padNotes.forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    gain.gain.value = 0.02;
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    lfo.frequency.value = 0.1 + i * 0.03;
    lfoGain.gain.value = 0.004;
    lfo.connect(lfoGain);
    lfoGain.connect(gain.gain);
    lfo.start();
    osc.connect(gain);
    gain.connect(master);
    osc.start();
    ambientNodes.push(osc, lfo, gain);
  });

  const bpm = 68;
  const stepTime = 60 / bpm / 2;

  const melody = [
    523.25, 0, 493.88, 0, 440, 0, 392, 329.63,
    0, 349.23, 0, 329.63, 0, 0, 293.66, 0,
    329.63, 0, 349.23, 392, 0, 440, 0, 0,
    493.88, 0, 523.25, 0, 587.33, 0, 523.25, 0,
    440, 0, 466.16, 0, 440, 0, 392, 0,
    349.23, 0, 329.63, 0, 293.66, 329.63, 0, 0,
    261.63, 0, 293.66, 329.63, 0, 392, 0, 440,
    0, 493.88, 0, 0, 523.25, 0, 0, 0
  ];

  const bass = [
    130.81, 0, 146.83, 0, 164.81, 0, 174.61, 0,
    196.00, 0, 174.61, 0, 164.81, 0, 146.83, 0,
    130.81, 0, 138.59, 0, 146.83, 0, 164.81, 0,
    174.61, 0, 196.00, 0, 220.00, 0, 196.00, 0,
    164.81, 0, 174.61, 0, 196.00, 0, 220.00, 0,
    246.94, 0, 220.00, 0, 196.00, 0, 174.61, 0,
    164.81, 0, 146.83, 0, 130.81, 0, 146.83, 0,
    164.81, 0, 174.61, 0, 196.00, 0, 220.00, 0
  ];

  const arp = [261.63, 329.63, 392, 493.88, 523.25, 493.88, 392, 329.63];
  let arpIdx = 0, step = 0;

  function playNote(freq, type, vol, duration, dest) {
    if (freq === 0) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(dest);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  function tick() {
    if (!soundOn) return;
    const idx = step % melody.length;
    playNote(melody[idx], 'square', 0.04, stepTime * 1.8, master);
    if (melody[idx]) playNote(melody[idx], 'square', 0.015, stepTime * 1.8, delay);
    playNote(bass[idx], 'triangle', 0.07, stepTime * 1.6, master);
    if (step % 4 === 0) {
      playNote(arp[arpIdx % arp.length] * 2, 'sine', 0.02, stepTime * 0.8, master);
      arpIdx++;
    }
    if (step % 2 === 0) {
      const bufferSize = audioCtx.sampleRate * 0.04;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.15;
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.012, audioCtx.currentTime);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.04);
      const hpf = audioCtx.createBiquadFilter();
      hpf.type = 'highpass'; hpf.frequency.value = 9000;
      noise.connect(hpf); hpf.connect(noiseGain); noiseGain.connect(master);
      noise.start(); noise.stop(audioCtx.currentTime + 0.04);
    }
    if (step % 8 === 0) {
      const kick = audioCtx.createOscillator();
      const kickGain = audioCtx.createGain();
      kick.type = 'sine';
      kick.frequency.setValueAtTime(120, audioCtx.currentTime);
      kick.frequency.exponentialRampToValueAtTime(25, audioCtx.currentTime + 0.15);
      kickGain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      kickGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);
      kick.connect(kickGain); kickGain.connect(master);
      kick.start(); kick.stop(audioCtx.currentTime + 0.18);
    }
    step++;
  }

  chiptuneInterval = setInterval(tick, stepTime * 1000);
}

function stopAmbient() {
  if (chiptuneInterval) { clearInterval(chiptuneInterval); chiptuneInterval = null; }
  ambientNodes.forEach(n => { try { n.stop?.(); n.disconnect(); } catch(e){} });
  ambientNodes = [];
}

// ============================================================
// AMBIENT LIGHTING
// ============================================================
function drawAmbientLighting(t) {
  // Wall screen glow
  const s = ROOM.wallScreen;
  const grad = ctx.createRadialGradient(
    (s.x + s.w/2) * SCALE, (s.y + s.h/2) * SCALE, 10 * SCALE,
    (s.x + s.w/2) * SCALE, (s.y + s.h/2) * SCALE, 120 * SCALE
  );
  grad.addColorStop(0, 'rgba(201,168,76,0.04)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, VW * SCALE, VH * SCALE);

  // Window moonlight
  const w = ROOM.window;
  const grad2 = ctx.createRadialGradient(
    (w.x + w.w/2) * SCALE, (w.y + w.h/2) * SCALE, 5 * SCALE,
    (w.x + w.w/2) * SCALE, (w.y + w.h) * SCALE, 90 * SCALE
  );
  grad2.addColorStop(0, 'rgba(150,160,200,0.04)');
  grad2.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad2;
  ctx.fillRect(0, 0, VW * SCALE, VH * SCALE);

  // Glenn's green glow
  const g = ROOM.glennDesk;
  const grad3 = ctx.createRadialGradient(
    (g.x + g.w/2) * SCALE, (g.y - 10) * SCALE, 5 * SCALE,
    (g.x + g.w/2) * SCALE, (g.y - 10) * SCALE, 45 * SCALE
  );
  grad3.addColorStop(0, 'rgba(0,255,65,0.04)');
  grad3.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad3;
  ctx.fillRect(0, 0, VW * SCALE, VH * SCALE);

  // Mallory's monitor glow ‚Äî warm purple
  const m = ROOM.malloryDesk;
  const grad4 = ctx.createRadialGradient(
    (m.x + m.w/2) * SCALE, (m.y - 10) * SCALE, 5 * SCALE,
    (m.x + m.w/2) * SCALE, (m.y - 10) * SCALE, 35 * SCALE
  );
  grad4.addColorStop(0, 'rgba(200,100,255,0.03)');
  grad4.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad4;
  ctx.fillRect(0, 0, VW * SCALE, VH * SCALE);
}

// ============================================================
// RUG
// ============================================================
function drawRug() {
  const rx = 160, ry = 225, rw = 160, rh = 50;
  ctx.fillStyle = 'rgba(74,21,32,0.3)';
  ctx.fillRect(rx * SCALE, ry * SCALE, rw * SCALE, rh * SCALE);
  // Border
  ctx.fillStyle = 'rgba(201,168,76,0.15)';
  ctx.fillRect(rx * SCALE, ry * SCALE, rw * SCALE, SCALE);
  ctx.fillRect(rx * SCALE, (ry + rh - 1) * SCALE, rw * SCALE, SCALE);
  ctx.fillRect(rx * SCALE, ry * SCALE, SCALE, rh * SCALE);
  ctx.fillRect((rx + rw - 1) * SCALE, ry * SCALE, SCALE, rh * SCALE);
  // Inner border
  ctx.fillStyle = 'rgba(201,168,76,0.08)';
  ctx.fillRect((rx + 3) * SCALE, (ry + 3) * SCALE, (rw - 6) * SCALE, SCALE);
  ctx.fillRect((rx + 3) * SCALE, (ry + rh - 4) * SCALE, (rw - 6) * SCALE, SCALE);
  // Pattern
  for (let px = rx + 8; px < rx + rw - 8; px += 16) {
    ctx.fillStyle = 'rgba(201,168,76,0.06)';
    ctx.fillRect(px * SCALE, (ry + rh/2 - 1) * SCALE, 8 * SCALE, 2 * SCALE);
  }
}

// ============================================================
// CEILING LAMP
// ============================================================
function drawCeilingLamp(t) {
  const lx = 240, ly = 4;
  // Chain
  ctx.fillStyle = 'rgba(201,168,76,0.4)';
  ctx.fillRect(lx * SCALE, ly * SCALE, SCALE, 12 * SCALE);
  // Lamp shade
  ctx.fillStyle = '#2C1810';
  ctx.fillRect((lx - 8) * SCALE, (ly + 12) * SCALE, 17 * SCALE, 6 * SCALE);
  ctx.fillStyle = 'rgba(201,168,76,0.3)';
  ctx.fillRect((lx - 8) * SCALE, (ly + 12) * SCALE, 17 * SCALE, SCALE);
  // Light glow
  const flicker = 0.03 + Math.sin(t * 8) * 0.005;
  const grad = ctx.createRadialGradient(
    lx * SCALE, (ly + 18) * SCALE, 2 * SCALE,
    lx * SCALE, (ly + 40) * SCALE, 60 * SCALE
  );
  grad.addColorStop(0, `rgba(255,220,150,${flicker})`);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, VW * SCALE, VH * SCALE);
  // Bulb
  ctx.fillStyle = `rgba(255,240,200,${0.6 + Math.sin(t * 8) * 0.1})`;
  ctx.fillRect((lx - 1) * SCALE, (ly + 18) * SCALE, 3 * SCALE, 3 * SCALE);
}

// ============================================================
// MAIN LOOP
// ============================================================
let time = 0;
function gameLoop() {
  time += 1/60;
  ctx.fillStyle = COL.bg1;
  ctx.fillRect(0, 0, W, H);

  drawWalls();
  drawCeilingLamp(time);
  drawWindow(time);
  drawWallClock(time);
  drawWallScreen(time);
  drawBookshelf();
  drawScoutStation(time);

  drawDesk(ROOM.cloeDesk, 2, '#001a00');
  drawDesk(ROOM.glennDesk, 3, '#001a00');
  drawDesk(ROOM.malloryDesk, 2, '#1a001a');
  drawTradingTerminal(time);
  drawMalloryMonitor(time);

  drawFloor();
  drawRug();

  drawCouch();
  drawCoffeeMachine(time);

  // Plants
  drawPlant(ROOM.plant1.x, ROOM.plant1.y, 10, time);
  drawPlant(ROOM.plant2.x, ROOM.plant2.y, 8, time + 1);
  drawPlant(ROOM.plant3.x, ROOM.plant3.y, 10, time + 2);

  drawAmbientLighting(time);

  agents.forEach(a => a.update(1/60));
  const sorted = [...agents].sort((a, b) => a.y - b.y);
  sorted.forEach(a => a.draw(time));

  updateParticles(1/60);
  drawParticles();

  // Vignette
  const grad = ctx.createRadialGradient(W/2, H/2, W * 0.25, W/2, H/2, W * 0.65);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
